#####
Nodes
#####

Nodes are the recursive backbone backbone of the Configuration object. Nodes can contain
other nodes under their attributes and in that way recurse deeper into the configuration.
Nodes can also be used as types of configuration dictionaries or lists.

Node classes contain the description of a node type in the configuration. Here's an example
to illustrate:

.. code-block:: python

  from bsb import config

  @config.node
  class CellType:
    name = config.attr(key=True)
    color = config.attr()
    radius = config.attr(type=float, required=True)

This node class describes the following configuration:

.. code-block:: json

  {
    "cell_type_name": {
      "radius": 13.0,
      "color": "red"
    }
  }

The ``@config.node`` decorator takes the ordinary class and injects the logic it needs
to fulfill the tasks of a configuration node. Whenever a node of this type is used
in the configuration an instance of the node class is created and some work needs to happen:

* The parsed configuration dictionary needs to be cast into an instance of the node class.
* The configuration attributes of this node class and its parents need to be collected.
* The attributes on this instance need to be initialized with a default value or ``None``.
* The keys that are present in the configuration dictionary need to be transferred to the
  node instance and converted to the specified type (the default type is ``str``)

Dynamic nodes
=============

Dynamic nodes are those whose node class is configurable from inside the configuration node itself.
This is done through the use of the ``@dynamic`` decorator instead of the node decorator.
This will automatically create a required ``class`` attribute.

The value that is given to this class attribute will be used to import a class to instantiate
the node:

.. code-block:: python

  @config.dynamic
  class PlacementStrategy:
    @abc.abstractmethod
    def place(self):
      pass

And in the configuration:

.. code-block:: json

  {
    "cls": "bsb.placement.LayeredRandomWalk"
  }

This would import the ``bsb.placement`` module and use its ``LayeredRandomWalk`` class to
decorate the node.

.. note::

	The child class must inherit from the dynamic node class.


Configuring the dynamic attribute
---------------------------------

Additional keyword arguments can be passed to the `dynamic` decorator to specify
the properties of the dynamic attribute. All keyword args are passed to the `attr`
decorator to create the attribute on the class that specifies the dynamics.

* ``attr_name``, ``required`` and ``default``:

.. code-block:: python

  @config.dynamic(attr_name="example_type", required=False, default="Example")
  class Example:
    pass

  @config.node
  class Explicit(Example):
    pass

``Example`` can then be defined as either:

.. code-block:: json

  {
    "example_type": "Explicit"
  }

or use the default ``Example`` implicitly by omitting the dynamic attribute:

.. code-block:: json

  {

  }

.. _classmap:

Class maps
----------

A preset map of shorter entries can be given to be mapped to an absolute or
relative class path, or a class object:

.. code-block:: python

   @dynamic(classmap={"short": "pkg.with.a.long.name.DynClass"})
   class Example:
       pass

If ``short`` is used the dynamic class will resolve to ``pkg.with.a.long.name.DynClass``.

Automatic class maps
~~~~~~~~~~~~~~~~~~~~

Automatic class maps can be generated by setting the ``auto_classmap`` keyword argument.
Child classes can then register themselves in the classmap of the parent by providing the
``classmap_entry`` keyword argument in their class definition argument list.

.. code-block:: python

  @dynamic(auto_classmap=True)
  class Example:
    pass

  class MappedChild(Example, classmap_entry="short"):
    pass

This will generate a mapping from ``short`` to the ``my.module.path.MappedChild`` class.

If the base class is not supposed to be abstract, it can be added to the
classmap as well:

.. code-block:: python

  @dynamic(auto_classmap=True, classmap_entry="self")
  class Example:
    pass

  class MappedChild(Example, classmap_entry="short"):
    pass


Root node
=========

The root node is the Configuration object and is at the basis of the tree of nodes.

Pluggable nodes
===============

A part of your configuration file might be using plugins, these plugins can behave quite
different from eachother and forcing them all to use the same configuration might hinder
their function or cause friction for users to configure them properly. To solve this
parts of the configuration are *pluggable*. This means that what needs to be configured
in the node can be determined by the plugin that you select for it. Homogeneity can be
enforced by defining *slots*. If a slot attribute is defined inside of a then the plugin
must provide an attribute with the same name.

.. note::

  	Currently the provided attribute slots enforce just the presence, not any kind of
  	inheritance or deeper inspection. It's up to a plugin author to understand the purpose
  	of the slot and to comply with its intentions.

Consider the following example:

.. code-block:: python

  import bsb.plugins, bsb.config

  @bsb.config.pluggable(key="plugin", plugin_name="puppy generator")
  class PluginNode:
    @classmethod
    def __plugins__(cls):
        if not hasattr(cls, "_plugins"):
            cls._plugins = bsb.plugins.discover("puppy_generators")
        return cls._plugins

.. code-block:: json

  {
    "plugin": "labradoodle",
    "labrador_percentage": 110,
    "poodle_percentage": 60
  }

The decorator argument ``key`` determines which attribute will be read to find out which
plugin the user wants to configure. The class method ``__plugins__`` will be used to
fetch the plugins every time a plugin is configured (usually finding these plugins isn't
that fast so caching them is recommended). The returned plugin objects should be
configuration node classes. These classes will then be used to further handle the given
configuration.
